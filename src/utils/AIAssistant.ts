import {
  AIGenerationRequest,
  AIGenerationResponse,
  APIKeyStorage,
} from '@/types/customNode';

const API_KEYS_STORAGE_KEY = 'three-nodes-ai-api-keys';

/**
 * AI Assistant for generating custom node code
 * Supports OpenAI and Anthropic APIs
 */
export class AIAssistant {
  /**
   * Save API keys to localStorage with basic obfuscation
   */
  static saveAPIKeys(keys: APIKeyStorage): void {
    const encoded = btoa(JSON.stringify(keys));
    localStorage.setItem(API_KEYS_STORAGE_KEY, encoded);
  }

  /**
   * Load API keys from environment variables first, then fall back to localStorage
   */
  static loadAPIKeys(): APIKeyStorage {
    const keys: APIKeyStorage = {};

    // Check environment variables first (Vite requires VITE_ prefix)
    if (import.meta.env.VITE_OPENAITOKEN) {
      keys.openai = import.meta.env.VITE_OPENAITOKEN;
    }
    if (import.meta.env.VITE_ANTHROPICTOKEN) {
      keys.anthropic = import.meta.env.VITE_ANTHROPICTOKEN;
    }

    // If env keys are set, return them
    if (keys.openai || keys.anthropic) {
      return keys;
    }

    // Fall back to localStorage
    try {
      const encoded = localStorage.getItem(API_KEYS_STORAGE_KEY);
      if (!encoded) {
        return {};
      }
      return JSON.parse(atob(encoded));
    } catch (error) {
      console.error('Failed to load API keys:', error);
      return {};
    }
  }

  /**
   * Check if an API key is configured for a provider (env or localStorage)
   */
  static hasAPIKey(provider: 'openai' | 'anthropic'): boolean {
    const keys = this.loadAPIKeys();
    return !!(provider === 'openai' ? keys.openai : keys.anthropic);
  }

  /**
   * Generate evaluate function code using AI
   */
  static async generateCode(request: AIGenerationRequest): Promise<AIGenerationResponse> {
    const keys = this.loadAPIKeys();
    const apiKey = request.provider === 'openai' ? keys.openai : keys.anthropic;

    if (!apiKey) {
      return {
        success: false,
        error: `No API key configured for ${request.provider}`,
      };
    }

    try {
      if (request.provider === 'openai') {
        return await this.generateWithOpenAI(request, apiKey);
      } else {
        return await this.generateWithAnthropic(request, apiKey);
      }
    } catch (error) {
      return {
        success: false,
        error: `AI generation failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }

  /**
   * Generate code using OpenAI API
   */
  private static async generateWithOpenAI(
    request: AIGenerationRequest,
    apiKey: string
  ): Promise<AIGenerationResponse> {
    const prompt = this.buildPrompt(request);

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content:
              'You are a helpful assistant that generates JavaScript/TypeScript code for node-based visual programming. Generate only the function body code without the function declaration. The code will be executed in the context of a Node instance with access to this.getInputValue(), this.setOutputValue(), and this.getProperty() methods.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        max_tokens: 1000,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
      throw new Error(error.error?.message || `API request failed with status ${response.status}`);
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error('No content generated by AI');
    }

    return this.parseResponse(content, request.mode);
  }

  /**
   * Generate code using Anthropic API
   */
  private static async generateWithAnthropic(
    request: AIGenerationRequest,
    apiKey: string
  ): Promise<AIGenerationResponse> {
    const prompt = this.buildPrompt(request);

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 1024,
        messages: [
          {
            role: 'user',
            content: `You are a helpful assistant that generates JavaScript/TypeScript code for node-based visual programming. Generate only the function body code without the function declaration. The code will be executed in the context of a Node instance with access to this.getInputValue(), this.setOutputValue(), and this.getProperty() methods.\n\n${prompt}`,
          },
        ],
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
      throw new Error(
        error.error?.message || `API request failed with status ${response.status}`
      );
    }

    const data = await response.json();
    const content = data.content?.[0]?.text;

    if (!content) {
      throw new Error('No content generated by AI');
    }

    return this.parseResponse(content, request.mode);
  }

  /**
   * Build prompt for AI generation
   */
  private static buildPrompt(request: AIGenerationRequest): string {
    if (request.mode === 'full') {
      return this.buildFullNodePrompt(request);
    } else {
      return this.buildCodeOnlyPrompt(request);
    }
  }

  /**
   * Build prompt for full node generation
   */
  private static buildFullNodePrompt(request: AIGenerationRequest): string {
    return `You are a helpful assistant that designs custom nodes for a Three.js node-based visual programming system.

Based on the following description, generate a COMPLETE node specification including inputs, outputs, properties, and the evaluate function code.

Description: ${request.description}

Respond ONLY with a valid JSON object in this exact format:
{
  "name": "NodeNameInPascalCase",
  "label": "Human Readable Label",
  "category": "CategoryName",
  "inputs": [
    {"name": "inputName", "type": "number"}
  ],
  "outputs": [
    {"name": "outputName", "type": "number"}
  ],
  "properties": [
    {"name": "propertyName", "type": "number", "value": 1, "label": "Property Label"}
  ],
  "code": "const input = this.getInputValue('inputName');\\nthis.setOutputValue('outputName', input);"
}

Available port types: number, boolean, string, vector3, color, matrix4, texture, geometry, material, object3d, scene, camera, light, point2d, any
Available property types: number, string, boolean, color

Available methods in code:
- this.getInputValue(name) - Get value from an input port
- this.setOutputValue(name, value) - Set value to an output port
- this.getProperty(name) - Get a property value
- Access to THREE.js library (e.g., new THREE.Vector3())

Generate ONLY the JSON, no other text.`;
  }

  /**
   * Build prompt for code-only generation
   */
  private static buildCodeOnlyPrompt(request: AIGenerationRequest): string {
    let prompt = `Generate an evaluate function body for a custom node with the following description:\n\n${request.description}\n\n`;

    if (request.existingInputs && request.existingInputs.length > 0) {
      prompt += 'Input ports:\n';
      for (const input of request.existingInputs) {
        prompt += `- ${input.name} (${input.type})${input.defaultValue !== undefined ? ` default: ${input.defaultValue}` : ''}\n`;
      }
      prompt += '\n';
    }

    if (request.existingOutputs && request.existingOutputs.length > 0) {
      prompt += 'Output ports:\n';
      for (const output of request.existingOutputs) {
        prompt += `- ${output.name} (${output.type})\n`;
      }
      prompt += '\n';
    }

    if (request.existingProperties && request.existingProperties.length > 0) {
      prompt += 'Properties:\n';
      for (const prop of request.existingProperties) {
        prompt += `- ${prop.name} (${prop.type})${prop.value !== undefined ? ` default: ${prop.value}` : ''}\n`;
      }
      prompt += '\n';
    }

    prompt += `Available methods:
- this.getInputValue(name) - Get value from an input port
- this.setOutputValue(name, value) - Set value to an output port
- this.getProperty(name) - Get a property value

Important:
- Only generate the function body code, not the function declaration
- Use proper error handling
- Return values by calling this.setOutputValue()
- The code will run in a Three.js node-based environment

Example:
const value = this.getInputValue('input');
const multiplier = this.getProperty('multiplier') || 1;
const result = value * multiplier;
this.setOutputValue('output', result);`;

    return prompt;
  }

  /**
   * Parse AI response based on mode
   */
  private static parseResponse(content: string, mode: 'full' | 'code-only'): AIGenerationResponse {
    if (mode === 'full') {
      // Extract JSON from response
      let jsonStr = content.trim();
      
      // Remove markdown code blocks
      jsonStr = jsonStr.replace(/^```(?:json|javascript|typescript)?\n?/gm, '');
      jsonStr = jsonStr.replace(/\n?```$/gm, '');
      
      try {
        const parsed = JSON.parse(jsonStr);
        
        return {
          success: true,
          code: parsed.code || '',
          nodeStructure: {
            name: parsed.name,
            label: parsed.label,
            category: parsed.category,
            inputs: parsed.inputs || [],
            outputs: parsed.outputs || [],
            properties: parsed.properties || [],
          },
        };
      } catch (error) {
        return {
          success: false,
          error: `Failed to parse AI response as JSON: ${error instanceof Error ? error.message : String(error)}`,
        };
      }
    } else {
      // Code-only mode
      return {
        success: true,
        code: this.extractCode(content),
      };
    }
  }

  /**
   * Extract code from AI response (remove markdown code blocks if present)
   */
  private static extractCode(response: string): string {
    // Remove markdown code blocks
    let code = response.trim();
    
    // Remove ```javascript or ```typescript or ```js blocks
    code = code.replace(/^```(?:javascript|typescript|js|ts)?\n?/gm, '');
    code = code.replace(/\n?```$/gm, '');
    
    return code.trim();
  }

  /**
   * Test if the AI API is reachable and the key is valid
   */
  static async testAPIKey(provider: 'openai' | 'anthropic'): Promise<{ valid: boolean; error?: string }> {
    try {
      const response = await this.generateCode({
        description: 'Test node that outputs the number 42',
        provider,
        mode: 'code-only',
        existingInputs: [],
        existingOutputs: [{ name: 'value', type: 'number' as any }],
      });

      if (response.success) {
        return { valid: true };
      } else {
        return { valid: false, error: response.error };
      }
    } catch (error) {
      return {
        valid: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}

